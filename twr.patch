diff -Naur kernel-old/arch/arm/mach-msm/include/mach/qdsp5v2/audio_dev_ctl.h kernel-new/arch/arm/mach-msm/include/mach/qdsp5v2/audio_dev_ctl.h
--- kernel-old/arch/arm/mach-msm/include/mach/qdsp5v2/audio_dev_ctl.h	2011-01-31 14:20:49.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/include/mach/qdsp5v2/audio_dev_ctl.h	2011-04-25 00:29:28.000000000 +0400
@@ -36,6 +36,10 @@
 #define DEVICE_IGNORE	0xff
 #define SESSION_IGNORE 0x00000000
 
+#define VOICE_STATE_INVALID 0x0
+#define VOICE_STATE_INCALL 0x1
+#define VOICE_STATE_OFFCALL 0x2
+
 struct msm_snddev_info {
 	const char *name;
 	u32 capability;
@@ -101,6 +105,7 @@
 	u32 acdb_id;
 	u32 sample_rate;
 	u32 dev_type;
+	u32 sessions;
 };
 
 union msm_vol_mute {
@@ -126,6 +131,7 @@
 	struct auddev_evt_freq_info freq_info;
 	u32 routing_id;
 	s32 session_vol;
+	s32 voice_state;
 	struct auddev_evt_audcal_info audcal_info;
 };
 
@@ -143,6 +149,7 @@
 #define AUDDEV_EVT_END_VOICE		0x40	/* voice call end */
 #define AUDDEV_EVT_STREAM_VOL_CHG	0x80 	/* device volume changed */
 #define AUDDEV_EVT_FREQ_CHG		0x100	/* Change in freq */
+#define AUDDEV_EVT_VOICE_STATE_CHG      0x200   /* Change in voice state */
 
 #define AUDDEV_CLNT_VOC 		0x1	/* Vocoder clients */
 #define AUDDEV_CLNT_DEC 		0x2	/* Decoder clients */
diff -Naur kernel-old/arch/arm/mach-msm/include/mach/qdsp5v2/audpreproc.h kernel-new/arch/arm/mach-msm/include/mach/qdsp5v2/audpreproc.h
--- kernel-old/arch/arm/mach-msm/include/mach/qdsp5v2/audpreproc.h	2011-01-31 14:20:49.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/include/mach/qdsp5v2/audpreproc.h	2011-04-25 00:29:28.000000000 +0400
@@ -32,6 +32,12 @@
 #include <mach/qdsp5v2/qdsp5audpreproccmdi.h>
 #include <mach/qdsp5v2/qdsp5audpreprocmsg.h>
 
+#define MSM_AUD_ENC_MODE_TUNNEL  0x00000100
+#define MSM_AUD_ENC_MODE_NONTUNNEL  0x00000200
+
+#define SOURCE_PIPE_1   0x0001
+#define SOURCE_PIPE_0   0x0000
+
 /* event callback routine prototype*/
 typedef void (*audpreproc_event_func)(void *private, unsigned id, void *msg);
 
diff -Naur kernel-old/arch/arm/mach-msm/include/mach/qdsp5v2/qdsp5audpreproccmdi.h kernel-new/arch/arm/mach-msm/include/mach/qdsp5v2/qdsp5audpreproccmdi.h
--- kernel-old/arch/arm/mach-msm/include/mach/qdsp5v2/qdsp5audpreproccmdi.h	2011-01-31 14:20:49.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/include/mach/qdsp5v2/qdsp5audpreproccmdi.h	2011-04-25 00:29:28.000000000 +0400
@@ -218,7 +218,8 @@
 	unsigned short stream_id;
 	unsigned short destination_activity;
 	unsigned short source_mix_mask;
-	unsigned short reserved[2];
+	unsigned short pipe_id;
+	unsigned short reserved;
 } __attribute__((packed));
 
 /*
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/adsp.c kernel-new/arch/arm/mach-msm/qdsp5v2/adsp.c
--- kernel-old/arch/arm/mach-msm/qdsp5v2/adsp.c	2011-01-31 14:21:08.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/adsp.c	2011-04-25 00:29:28.000000000 +0400
@@ -429,7 +429,7 @@
 								cmd_size);
 		if (rc == -EAGAIN)
 			udelay(50);
-	} while (rc == -EAGAIN && retries++ < 100);
+	} while (rc == -EAGAIN && retries++ < 300);
 	if (retries > 20)
 		MM_INFO("%s command took %d attempts: rc %d\n",
 			module->name, retries, rc);
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/adsp_info.c kernel-new/arch/arm/mach-msm/qdsp5v2/adsp_info.c
--- kernel-old/arch/arm/mach-msm/qdsp5v2/adsp_info.c	2011-01-31 14:21:08.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/adsp_info.c	2011-04-25 00:29:28.000000000 +0400
@@ -64,6 +64,7 @@
 #define QDSP_MODULE_VDEC_LP_MODE_TURBO      0x01089f7a
 #define QDSP_MODULE_AUDREC0TASK             0x0109696f
 #define QDSP_MODULE_AUDREC1TASK             0x01096970
+#define QDSP_MODULE_AUDREC2TASK             0x010a2f59
 #define QDSP_MODULE_MAX                     0x7fffffff
 
    /* DO NOT USE: Force this enum to be a 32bit type to improve speed */
@@ -87,6 +88,7 @@
 	QDSP_MODULE(AFETASK , NULL, 0, NULL, NULL),
 	QDSP_MODULE(AUDREC0TASK, NULL, 0, NULL, NULL),
 	QDSP_MODULE(AUDREC1TASK, NULL, 0, NULL, NULL),
+     // QDSP_MODULE(AUDREC2TASK, NULL, 0, NULL, NULL),
 };
 
 int adsp_init_info(struct adsp_info *info)
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c kernel-new/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c
--- kernel-old/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c	1970-01-01 03:00:00.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c	2011-04-25 00:29:28.000000000 +0400
@@ -0,0 +1,899 @@
+/*
+ * amrnb audio input device
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Copyright (C) 2008 HTC Corporation
+ * Copyright (c) 2009-2010, Code Aurora Forum. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+//#include <linux/msm_audio_amrnb.h>
+
+#include <linux/msm_audio_7X30.h>
+
+#include <asm/atomic.h>
+#include <asm/ioctls.h>
+
+#include <mach/msm_adsp.h>
+#include <mach/qdsp5v2/qdsp5audreccmdi.h>
+#include <mach/qdsp5v2/qdsp5audrecmsg.h>
+#include <mach/qdsp5v2/audpreproc.h>
+#include <mach/qdsp5v2/audio_dev_ctl.h>
+//#include <mach/debug_mm.h>
+#include <mach/debug_audio_mm.h>
+
+/* FRAME_NUM must be a power of two */
+#define FRAME_NUM		(8)
+#define FRAME_SIZE		(22 * 2) /* 36 bytes data */
+#define DMASZ 			(FRAME_SIZE * FRAME_NUM)
+#define AUDIO_GET_VOICE_STATE   _IOR(AUDIO_IOCTL_MAGIC, 55, unsigned)
+
+#define AUDIO_GET_AMRNB_ENC_CONFIG  _IOW(AUDIO_IOCTL_MAGIC, \
+        (AUDIO_MAX_COMMON_IOCTL_NUM+0), unsigned)
+#define AUDIO_SET_AMRNB_ENC_CONFIG  _IOR(AUDIO_IOCTL_MAGIC, \
+        (AUDIO_MAX_COMMON_IOCTL_NUM+1), unsigned)
+#define AUDIO_GET_AMRNB_ENC_CONFIG_V2  _IOW(AUDIO_IOCTL_MAGIC, \
+        (AUDIO_MAX_COMMON_IOCTL_NUM+2), \
+        struct msm_audio_amrnb_enc_config_v2)
+#define AUDIO_SET_AMRNB_ENC_CONFIG_V2  _IOR(AUDIO_IOCTL_MAGIC, \
+        (AUDIO_MAX_COMMON_IOCTL_NUM+3), \
+        struct msm_audio_amrnb_enc_config_v2)
+
+struct msm_audio_amrnb_enc_config {
+        unsigned short voicememoencweight1;
+        unsigned short voicememoencweight2;
+        unsigned short voicememoencweight3;
+        unsigned short voicememoencweight4;
+        unsigned short dtx_mode_enable; /* 0xFFFF - enable, 0- disable */
+        unsigned short test_mode_enable; /* 0xFFFF - enable, 0- disable */
+        unsigned short enc_mode; /* 0-MR475,1-MR515,2-MR59,3-MR67,4-MR74
+                                5-MR795, 6- MR102, 7- MR122(default) */
+};
+
+struct msm_audio_amrnb_enc_config_v2 {
+        uint32_t band_mode;
+        uint32_t dtx_enable;
+        uint32_t frame_format;
+};
+
+int msm_get_voice_state(void);
+
+
+
+struct buffer {
+	void *data;
+	uint32_t size;
+	uint32_t read;
+	uint32_t addr;
+};
+
+struct audio_in {
+	struct buffer in[FRAME_NUM];
+
+	spinlock_t dsp_lock;
+
+	atomic_t in_bytes;
+	atomic_t in_samples;
+
+	struct mutex lock;
+	struct mutex read_lock;
+	wait_queue_head_t wait;
+	wait_queue_head_t wait_enable;
+
+	struct msm_adsp_module *audrec;
+
+	/* configuration to use on next enable */
+	uint32_t buffer_size; /* Frame size (36 bytes) */
+	uint32_t enc_type;
+
+	int dtx_mode;
+	uint32_t frame_format;
+	uint32_t used_mode;
+	uint32_t rec_mode;
+
+	uint32_t dsp_cnt;
+	uint32_t in_head; /* next buffer dsp will write */
+	uint32_t in_tail; /* next buffer read() will read */
+	uint32_t in_count; /* number of buffers available to read() */
+	uint32_t mode;
+
+	const char *module_name;
+	unsigned queue_ids;
+	uint16_t enc_id;
+
+	uint16_t source; /* Encoding source bit mask */
+	uint32_t device_events;
+	uint32_t in_call;
+	uint32_t dev_cnt;
+	int voice_state;
+	spinlock_t dev_lock;
+
+	/* data allocated for various buffers */
+	char *data;
+	dma_addr_t phys;
+
+	int opened;
+	int enabled;
+	int running;
+	int stopped; /* set when stopped, cleared on flush */
+};
+
+struct audio_frame {
+	uint16_t frame_count_lsw;
+	uint16_t frame_count_msw;
+	uint16_t frame_length;
+	uint16_t erased_pcm;
+	unsigned char raw_bitstream[]; /* samples */
+} __attribute__((packed));
+
+/* Audrec Queue command sent macro's */
+#define audrec_send_bitstreamqueue(audio, cmd, len) \
+	msm_adsp_write(audio->audrec, ((audio->queue_ids & 0xFFFF0000) >> 16),\
+			cmd, len)
+
+#define audrec_send_audrecqueue(audio, cmd, len) \
+	msm_adsp_write(audio->audrec, (audio->queue_ids & 0x0000FFFF),\
+			cmd, len)
+
+struct audio_in the_audio_amrnb_in;
+
+/* DSP command send functions */
+static int audamrnb_in_enc_config(struct audio_in *audio, int enable);
+static int audamrnb_in_param_config(struct audio_in *audio);
+static int audamrnb_in_mem_config(struct audio_in *audio);
+static int audamrnb_in_record_config(struct audio_in *audio, int enable);
+static int audamrnb_dsp_read_buffer(struct audio_in *audio, uint32_t read_cnt);
+
+static void audamrnb_in_get_dsp_frames(struct audio_in *audio);
+
+static void audamrnb_in_flush(struct audio_in *audio);
+
+static void amrnb_in_listener(u32 evt_id, union auddev_evt_data *evt_payload,
+				void *private_data)
+{
+	struct audio_in *audio = (struct audio_in *) private_data;
+	unsigned long flags;
+
+	MM_DBG("evt_id = 0x%8x\n", evt_id);
+	switch (evt_id) {
+	case AUDDEV_EVT_DEV_RDY: {
+		MM_DBG("AUDDEV_EVT_DEV_RDY\n");
+		spin_lock_irqsave(&audio->dev_lock, flags);
+		audio->dev_cnt++;
+		if (!audio->in_call)
+			audio->source |= (0x1 << evt_payload->routing_id);
+		spin_unlock_irqrestore(&audio->dev_lock, flags);
+
+		if ((audio->running == 1) && (audio->enabled == 1))
+			audamrnb_in_record_config(audio, 1);
+
+		break;
+	}
+	case AUDDEV_EVT_DEV_RLS: {
+		MM_DBG("AUDDEV_EVT_DEV_RLS\n");
+		spin_lock_irqsave(&audio->dev_lock, flags);
+		audio->dev_cnt--;
+		if (!audio->in_call)
+			audio->source &= ~(0x1 << evt_payload->routing_id);
+		spin_unlock_irqrestore(&audio->dev_lock, flags);
+
+		if ((!audio->running) || (!audio->enabled))
+			break;
+
+		/* Turn of as per source */
+		if (audio->source)
+			audamrnb_in_record_config(audio, 1);
+		else
+			/* Turn off all */
+			audamrnb_in_record_config(audio, 0);
+
+		break;
+	}
+	case AUDDEV_EVT_VOICE_STATE_CHG: {
+		MM_DBG("AUDDEV_EVT_VOICE_STATE_CHG, state = %d\n",
+				evt_payload->voice_state);
+		audio->voice_state = evt_payload->voice_state;
+		if (audio->in_call && audio->running) {
+			if (audio->voice_state == VOICE_STATE_INCALL)
+				audamrnb_in_record_config(audio, 1);
+			else if (audio->voice_state == VOICE_STATE_OFFCALL) {
+				audamrnb_in_record_config(audio, 0);
+				wake_up(&audio->wait);
+			}
+		}
+
+		break;
+	}
+	default:
+		MM_ERR("wrong event %d\n", evt_id);
+		break;
+	}
+}
+
+/* ------------------- dsp preproc event handler--------------------- */
+static void audpreproc_dsp_event(void *data, unsigned id,  void *msg)
+{
+	struct audio_in *audio = data;
+
+	switch (id) {
+	case AUDPREPROC_ERROR_MSG: {
+		struct audpreproc_err_msg *err_msg = msg;
+
+		MM_ERR("ERROR_MSG: stream id %d err idx %d\n",
+		err_msg->stream_id, err_msg->aud_preproc_err_idx);
+		/* Error case */
+		wake_up(&audio->wait_enable);
+		break;
+	}
+	case AUDPREPROC_CMD_CFG_DONE_MSG: {
+		MM_DBG("CMD_CFG_DONE_MSG \n");
+		break;
+	}
+	case AUDPREPROC_CMD_ENC_CFG_DONE_MSG: {
+		struct audpreproc_cmd_enc_cfg_done_msg *enc_cfg_msg = msg;
+
+		MM_DBG("CMD_ENC_CFG_DONE_MSG: stream id %d enc type \
+			0x%8x\n", enc_cfg_msg->stream_id,
+			enc_cfg_msg->rec_enc_type);
+		/* Encoder enable success */
+		if (enc_cfg_msg->rec_enc_type & ENCODE_ENABLE)
+			audamrnb_in_param_config(audio);
+		else { /* Encoder disable success */
+			audio->running = 0;
+			audamrnb_in_record_config(audio, 0);
+		}
+		break;
+	}
+	case AUDPREPROC_CMD_ENC_PARAM_CFG_DONE_MSG: {
+		MM_DBG("CMD_ENC_PARAM_CFG_DONE_MSG \n");
+		audamrnb_in_mem_config(audio);
+		break;
+	}
+	case AUDPREPROC_AFE_CMD_AUDIO_RECORD_CFG_DONE_MSG: {
+		MM_DBG("AFE_CMD_AUDIO_RECORD_CFG_DONE_MSG \n");
+		wake_up(&audio->wait_enable);
+		break;
+	}
+	default:
+		MM_ERR("Unknown Event id %d\n", id);
+	}
+}
+
+/* ------------------- dsp audrec event handler--------------------- */
+static void audrec_dsp_event(void *data, unsigned id, size_t len,
+			    void (*getevent)(void *ptr, size_t len))
+{
+	struct audio_in *audio = data;
+
+	switch (id) {
+	case AUDREC_CMD_MEM_CFG_DONE_MSG: {
+		MM_DBG("CMD_MEM_CFG_DONE MSG DONE\n");
+		audio->running = 1;
+		if ((!audio->in_call && (audio->dev_cnt > 0)) ||
+			(audio->in_call &&
+				(audio->voice_state == VOICE_STATE_INCALL)))
+			audamrnb_in_record_config(audio, 1);
+		break;
+	}
+	case AUDREC_FATAL_ERR_MSG: {
+		struct audrec_fatal_err_msg fatal_err_msg;
+
+		getevent(&fatal_err_msg, AUDREC_FATAL_ERR_MSG_LEN);
+		MM_ERR("FATAL_ERR_MSG: err id %d\n",
+				fatal_err_msg.audrec_err_id);
+		/* Error stop the encoder */
+		audio->stopped = 1;
+		wake_up(&audio->wait);
+		break;
+	}
+	case AUDREC_UP_PACKET_READY_MSG: {
+		struct audrec_up_pkt_ready_msg pkt_ready_msg;
+
+		getevent(&pkt_ready_msg, AUDREC_UP_PACKET_READY_MSG_LEN);
+		MM_DBG("UP_PACKET_READY_MSG: write cnt lsw  %d \
+		write cnt msw %d read cnt lsw %d  read cnt msw %d \n",\
+		pkt_ready_msg.audrec_packet_write_cnt_lsw, \
+		pkt_ready_msg.audrec_packet_write_cnt_msw, \
+		pkt_ready_msg.audrec_up_prev_read_cnt_lsw, \
+		pkt_ready_msg.audrec_up_prev_read_cnt_msw);
+
+		audamrnb_in_get_dsp_frames(audio);
+		break;
+	}
+	default:
+		MM_ERR("Unknown Event id %d\n", id);
+	}
+}
+
+static void audamrnb_in_get_dsp_frames(struct audio_in *audio)
+{
+	struct audio_frame *frame;
+	uint32_t index;
+	unsigned long flags;
+
+	index = audio->in_head;
+
+	frame = (void *) (((char *)audio->in[index].data) - \
+			 sizeof(*frame));
+
+	spin_lock_irqsave(&audio->dsp_lock, flags);
+	audio->in[index].size = frame->frame_length;
+
+	/* statistics of read */
+	atomic_add(audio->in[index].size, &audio->in_bytes);
+	atomic_add(1, &audio->in_samples);
+
+	audio->in_head = (audio->in_head + 1) & (FRAME_NUM - 1);
+
+	/* If overflow, move the tail index foward. */
+	if (audio->in_head == audio->in_tail)
+		audio->in_tail = (audio->in_tail + 1) & (FRAME_NUM - 1);
+	else
+		audio->in_count++;
+
+	audamrnb_dsp_read_buffer(audio, audio->dsp_cnt++);
+	spin_unlock_irqrestore(&audio->dsp_lock, flags);
+
+	wake_up(&audio->wait);
+}
+struct msm_adsp_ops audrec_amrnb_adsp_ops = {
+	.event = audrec_dsp_event,
+};
+
+static int audamrnb_in_enc_config(struct audio_in *audio, int enable)
+{
+	struct audpreproc_audrec_cmd_enc_cfg cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.cmd_id = AUDPREPROC_AUDREC_CMD_ENC_CFG;
+	cmd.stream_id = audio->enc_id;
+
+	if (enable)
+		cmd.audrec_enc_type = audio->enc_type | ENCODE_ENABLE;
+	else
+		cmd.audrec_enc_type &= ~(ENCODE_ENABLE);
+
+	return audpreproc_send_audreccmdqueue(&cmd, sizeof(cmd));
+}
+
+static int audamrnb_in_param_config(struct audio_in *audio)
+{
+	struct audpreproc_audrec_cmd_parm_cfg_amrnb cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.common.cmd_id = AUDPREPROC_AUDREC_CMD_PARAM_CFG;
+	cmd.common.stream_id = audio->enc_id;
+
+	cmd.dtx_mode = audio->dtx_mode;
+	cmd.test_mode = -1; /* Default set to -1 */
+	cmd.used_mode = audio->used_mode;
+
+	return audpreproc_send_audreccmdqueue(&cmd, sizeof(cmd));
+}
+
+/* To Do: msm_snddev_route_enc(audio->enc_id); */
+static int audamrnb_in_record_config(struct audio_in *audio, int enable)
+{
+	struct audpreproc_afe_cmd_audio_record_cfg cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.cmd_id = AUDPREPROC_AFE_CMD_AUDIO_RECORD_CFG;
+	cmd.stream_id = audio->enc_id;
+	if (enable)
+		cmd.destination_activity = AUDIO_RECORDING_TURN_ON;
+	else
+		cmd.destination_activity = AUDIO_RECORDING_TURN_OFF;
+
+	cmd.source_mix_mask = audio->source;
+	if (audio->enc_id == 2) {
+		if ((cmd.source_mix_mask &
+				INTERNAL_CODEC_TX_SOURCE_MIX_MASK) ||
+			(cmd.source_mix_mask & AUX_CODEC_TX_SOURCE_MIX_MASK) ||
+			(cmd.source_mix_mask & VOICE_UL_SOURCE_MIX_MASK) ||
+			(cmd.source_mix_mask & VOICE_DL_SOURCE_MIX_MASK)) {
+			cmd.pipe_id = SOURCE_PIPE_1;
+		}
+		if (cmd.source_mix_mask &
+				AUDPP_A2DP_PIPE_SOURCE_MIX_MASK)
+			cmd.pipe_id |= SOURCE_PIPE_0;
+	}
+
+	return audpreproc_send_audreccmdqueue(&cmd, sizeof(cmd));
+}
+
+static int audamrnb_in_mem_config(struct audio_in *audio)
+{
+	struct audrec_cmd_arecmem_cfg cmd;
+	uint16_t *data = (void *) audio->data;
+	int n;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.cmd_id = AUDREC_CMD_MEM_CFG_CMD;
+	cmd.audrec_up_pkt_intm_count = 1;
+	cmd.audrec_ext_pkt_start_addr_msw = audio->phys >> 16;
+	cmd.audrec_ext_pkt_start_addr_lsw = audio->phys;
+	cmd.audrec_ext_pkt_buf_number = FRAME_NUM;
+
+	/* prepare buffer pointers:
+	 * 36 bytes amrnb packet + 4 halfword header
+	 */
+	for (n = 0; n < FRAME_NUM; n++) {
+		audio->in[n].data = data + 4;
+		data += (FRAME_SIZE/2); /* word increment */
+		MM_DBG("0x%8x\n", (int)(audio->in[n].data - 8));
+	}
+
+	return audrec_send_audrecqueue(audio, &cmd, sizeof(cmd));
+}
+
+static int audamrnb_dsp_read_buffer(struct audio_in *audio, uint32_t read_cnt)
+{
+	struct up_audrec_packet_ext_ptr cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.cmd_id = UP_AUDREC_PACKET_EXT_PTR;
+	cmd.audrec_up_curr_read_count_msw = read_cnt >> 16;
+	cmd.audrec_up_curr_read_count_lsw = read_cnt;
+
+	return audrec_send_bitstreamqueue(audio, &cmd, sizeof(cmd));
+}
+
+/* must be called with audio->lock held */
+static int audamrnb_in_enable(struct audio_in *audio)
+{
+	if (audio->enabled)
+		return 0;
+
+	if (audpreproc_enable(audio->enc_id, &audpreproc_dsp_event, audio)) {
+		MM_ERR("msm_adsp_enable(audpreproc) failed\n");
+		return -ENODEV;
+	}
+
+	if (msm_adsp_enable(audio->audrec)) {
+		MM_ERR("msm_adsp_enable(audrec) failed\n");
+		audpreproc_disable(audio->enc_id, audio);
+		return -ENODEV;
+	}
+	audio->enabled = 1;
+	audamrnb_in_enc_config(audio, 1);
+
+	return 0;
+}
+
+/* must be called with audio->lock held */
+static int audamrnb_in_disable(struct audio_in *audio)
+{
+	if (audio->enabled) {
+		audio->enabled = 0;
+		audamrnb_in_enc_config(audio, 0);
+		wake_up(&audio->wait);
+		wait_event_interruptible_timeout(audio->wait_enable,
+				audio->running == 0, 1*HZ);
+		msm_adsp_disable(audio->audrec);
+		audpreproc_disable(audio->enc_id, audio);
+	}
+	return 0;
+}
+
+static void audamrnb_in_flush(struct audio_in *audio)
+{
+	int i;
+
+	audio->dsp_cnt = 0;
+	audio->in_head = 0;
+	audio->in_tail = 0;
+	audio->in_count = 0;
+	for (i = 0; i < FRAME_NUM; i++) {
+		audio->in[i].size = 0;
+		audio->in[i].read = 0;
+	}
+	MM_DBG("in_bytes %d\n", atomic_read(&audio->in_bytes));
+	MM_DBG("in_samples %d\n", atomic_read(&audio->in_samples));
+	atomic_set(&audio->in_bytes, 0);
+	atomic_set(&audio->in_samples, 0);
+}
+
+/* ------------------- device --------------------- */
+static long audamrnb_in_ioctl(struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	struct audio_in *audio = file->private_data;
+	int rc = 0;
+
+	if (cmd == AUDIO_GET_STATS) {
+		struct msm_audio_stats stats;
+		stats.byte_count = atomic_read(&audio->in_bytes);
+		stats.sample_count = atomic_read(&audio->in_samples);
+		if (copy_to_user((void *) arg, &stats, sizeof(stats)))
+			return -EFAULT;
+		return rc;
+        } else if (cmd == AUDIO_GET_VOICE_STATE) {
+                int vstate = audio->voice_state;
+                if (copy_to_user((void *) arg, &vstate, sizeof(vstate))) 
+			return -EFAULT;
+                return rc;
+        }
+
+	mutex_lock(&audio->lock);
+	switch (cmd) {
+	case AUDIO_START: {
+		uint32_t freq;
+		freq = 48000;
+		MM_DBG("AUDIO_START\n");
+		if (audio->in_call && (audio->voice_state !=
+				VOICE_STATE_INCALL)) {
+			rc = -EPERM;
+			break;
+		}
+		rc = msm_snddev_request_freq(&freq, audio->enc_id,
+					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
+		MM_DBG("sample rate configured %d\n", freq);
+		if (rc < 0) {
+			MM_DBG(" Sample rate can not be set, return code %d\n",
+								 rc);
+			msm_snddev_withdraw_freq(audio->enc_id,
+					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
+			MM_DBG("msm_snddev_withdraw_freq\n");
+			break;
+		}
+		rc = audamrnb_in_enable(audio);
+		if (!rc) {
+			rc =
+			wait_event_interruptible_timeout(audio->wait_enable,
+				audio->running != 0, 1*HZ);
+			MM_DBG("state %d rc = %d\n", audio->running, rc);
+
+			if (audio->running == 0)
+				rc = -ENODEV;
+			else
+				rc = 0;
+		}
+		audio->stopped = 0;
+		break;
+	}
+	case AUDIO_STOP: {
+		rc = audamrnb_in_disable(audio);
+		rc = msm_snddev_withdraw_freq(audio->enc_id,
+					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
+		MM_DBG("AUDIO_STOP: msm_snddev_withdraw_freq\n");
+		audio->stopped = 1;
+		break;
+	}
+	case AUDIO_FLUSH: {
+		if (audio->stopped) {
+			/* Make sure we're stopped and we wake any threads
+			 * that might be blocked holding the read_lock.
+			 * While audio->stopped read threads will always
+			 * exit immediately.
+			 */
+			wake_up(&audio->wait);
+			mutex_lock(&audio->read_lock);
+			audamrnb_in_flush(audio);
+			mutex_unlock(&audio->read_lock);
+		}
+		break;
+	}
+	case AUDIO_SET_STREAM_CONFIG: {
+		struct msm_audio_stream_config cfg;
+		if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
+			rc = -EFAULT;
+			break;
+		}
+		/* Allow only single frame */
+		if (cfg.buffer_size != (FRAME_SIZE - 8))
+			rc = -EINVAL;
+		else
+			audio->buffer_size = cfg.buffer_size;
+		break;
+	}
+	case AUDIO_GET_STREAM_CONFIG: {
+		struct msm_audio_stream_config cfg;
+		memset(&cfg, 0, sizeof(cfg));
+		cfg.buffer_size = audio->buffer_size;
+		cfg.buffer_count = FRAME_NUM;
+		if (copy_to_user((void *) arg, &cfg, sizeof(cfg)))
+			rc = -EFAULT;
+		break;
+	}
+	case AUDIO_GET_AMRNB_ENC_CONFIG_V2: {
+		struct msm_audio_amrnb_enc_config_v2 cfg;
+		memset(&cfg, 0, sizeof(cfg));
+		cfg.dtx_enable = ((audio->dtx_mode == -1) ? 1 : 0);
+		cfg.band_mode = audio->used_mode;
+		cfg.frame_format = audio->frame_format;
+		if (copy_to_user((void *) arg, &cfg, sizeof(cfg)))
+			rc = -EFAULT;
+		break;
+	}
+	case AUDIO_SET_AMRNB_ENC_CONFIG_V2: {
+		struct msm_audio_amrnb_enc_config_v2 cfg;
+		if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
+			rc = -EFAULT;
+			break;
+		}
+		/* DSP does not support any other than default format */
+		if (audio->frame_format != cfg.frame_format) {
+			rc = -EINVAL;
+			break;
+		}
+		if (cfg.dtx_enable == 0)
+			audio->dtx_mode = 0;
+		else if (cfg.dtx_enable == 1)
+			audio->dtx_mode = -1;
+		else {
+			rc = -EINVAL;
+			break;
+		}
+		audio->used_mode = cfg.band_mode;
+		break;
+	}
+	case AUDIO_SET_INCALL: {
+		struct msm_voicerec_mode cfg;
+		unsigned long flags;
+		if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
+			rc = -EFAULT;
+			break;
+		}
+		if (cfg.rec_mode != VOC_REC_BOTH &&
+			cfg.rec_mode != VOC_REC_UPLINK &&
+			cfg.rec_mode != VOC_REC_DOWNLINK) {
+			MM_ERR("invalid rec_mode\n");
+			rc = -EINVAL;
+			break;
+		} else {
+			spin_lock_irqsave(&audio->dev_lock, flags);
+			if (cfg.rec_mode == VOC_REC_UPLINK)
+				audio->source = VOICE_UL_SOURCE_MIX_MASK;
+			else if (cfg.rec_mode == VOC_REC_DOWNLINK)
+				audio->source = VOICE_DL_SOURCE_MIX_MASK;
+			else
+				audio->source = VOICE_DL_SOURCE_MIX_MASK |
+						VOICE_UL_SOURCE_MIX_MASK ;
+			audio->in_call = 1;
+			spin_unlock_irqrestore(&audio->dev_lock, flags);
+		}
+		break;
+	}
+	case AUDIO_GET_SESSION_ID: {
+		if (copy_to_user((void *) arg, &audio->enc_id,
+			sizeof(unsigned short))) {
+			rc = -EFAULT;
+		}
+		break;
+	}
+	default:
+		rc = -EINVAL;
+	}
+	mutex_unlock(&audio->lock);
+	return rc;
+}
+
+static ssize_t audamrnb_in_read(struct file *file,
+				char __user *buf,
+				size_t count, loff_t *pos)
+{
+	struct audio_in *audio = file->private_data;
+	unsigned long flags;
+	const char __user *start = buf;
+	void *data;
+	uint32_t index;
+	uint32_t size;
+	int rc = 0;
+
+	mutex_lock(&audio->read_lock);
+	while (count > 0) {
+		rc = wait_event_interruptible(
+			audio->wait, (audio->in_count > 0) || audio->stopped
+			|| (audio->in_call && audio->running &&
+				(audio->voice_state == VOICE_STATE_OFFCALL)));
+		if (rc < 0)
+			break;
+
+		if (!audio->in_count) {
+			if (audio->stopped)  {
+				rc = 0;/* End of File */
+				break;
+			} else if (audio->in_call && audio->running &&
+				(audio->voice_state == VOICE_STATE_OFFCALL)) {
+				MM_DBG("Not Permitted Voice Terminated\n");
+				rc = -EPERM; /* Voice Call stopped */
+				break;
+			}
+		}
+
+		index = audio->in_tail;
+		data = (uint8_t *) audio->in[index].data;
+		size = audio->in[index].size;
+		if (count >= size) {
+			if (copy_to_user(buf, data, size)) {
+				rc = -EFAULT;
+				break;
+			}
+			spin_lock_irqsave(&audio->dsp_lock, flags);
+			if (index != audio->in_tail) {
+				/* overrun -- data is
+				 * invalid and we need to retry */
+				spin_unlock_irqrestore(&audio->dsp_lock, flags);
+				continue;
+			}
+			audio->in[index].size = 0;
+			audio->in_tail = (audio->in_tail + 1) & (FRAME_NUM - 1);
+			audio->in_count--;
+			spin_unlock_irqrestore(&audio->dsp_lock, flags);
+			count -= size;
+			buf += size;
+		} else {
+			MM_ERR("short read\n");
+			break;
+		}
+	}
+	mutex_unlock(&audio->read_lock);
+
+	if (buf > start)
+		return buf - start;
+
+	return rc;
+}
+
+static ssize_t audamrnb_in_write(struct file *file,
+				const char __user *buf,
+				size_t count, loff_t *pos)
+{
+	return -EINVAL;
+}
+
+static int audamrnb_in_release(struct inode *inode, struct file *file)
+{
+	struct audio_in *audio = file->private_data;
+
+	MM_DBG("\n");
+	mutex_lock(&audio->lock);
+	audio->in_call = 0;
+	/* with draw frequency for session
+	   incase not stopped the driver */
+	msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX,
+					AUDDEV_CLNT_ENC);
+	auddev_unregister_evt_listner(AUDDEV_CLNT_ENC, audio->enc_id);
+	audamrnb_in_disable(audio);
+	audamrnb_in_flush(audio);
+	msm_adsp_put(audio->audrec);
+	audpreproc_aenc_free(audio->enc_id);
+	audio->audrec = NULL;
+	audio->opened = 0;
+	mutex_unlock(&audio->lock);
+	return 0;
+}
+
+static int audamrnb_in_open(struct inode *inode, struct file *file)
+{
+	struct audio_in *audio = &the_audio_amrnb_in;
+	int rc;
+	int encid;
+
+	mutex_lock(&audio->lock);
+	if (audio->opened) {
+		rc = -EBUSY;
+		goto done;
+	}
+	if ((file->f_mode & FMODE_WRITE) &&
+			(file->f_mode & FMODE_READ)) {
+		rc = -EACCES;
+		MM_ERR("Non tunnel encoding is not supported\n");
+		goto done;
+	} else if (!(file->f_mode & FMODE_WRITE) &&
+					(file->f_mode & FMODE_READ)) {
+		audio->mode = MSM_AUD_ENC_MODE_TUNNEL;
+		MM_DBG("Opened for tunnel mode encoding\n");
+	} else {
+		rc = -EACCES;
+		goto done;
+	}
+
+
+	/* Settings will be re-config at AUDIO_SET_CONFIG,
+	 * but at least we need to have initial config
+	 */
+	audio->buffer_size = (FRAME_SIZE - 8);
+	audio->enc_type = ENC_TYPE_AMRNB | audio->mode;
+	audio->dtx_mode = -1;
+	audio->frame_format = 0;
+	audio->used_mode = 7; /* Bit Rate 12.2 kbps MR122 */
+
+	encid = audpreproc_aenc_alloc(audio->enc_type, &audio->module_name,
+			&audio->queue_ids);
+	if (encid < 0) {
+		MM_ERR("No free encoder available\n");
+		rc = -ENODEV;
+		goto done;
+	}
+	audio->enc_id = encid;
+
+	rc = msm_adsp_get(audio->module_name, &audio->audrec,
+			   &audrec_amrnb_adsp_ops, audio);
+
+	if (rc) {
+		audpreproc_aenc_free(audio->enc_id);
+		goto done;
+	}
+
+	audio->stopped = 0;
+	audio->source = 0;
+
+	audamrnb_in_flush(audio);
+
+	audio->device_events = AUDDEV_EVT_DEV_RDY | AUDDEV_EVT_DEV_RLS |
+				AUDDEV_EVT_VOICE_STATE_CHG;
+
+	audio->voice_state = msm_get_voice_state(); // VOICE_STATE_INCALL;
+
+	rc = auddev_register_evt_listner(audio->device_events,
+					AUDDEV_CLNT_ENC, audio->enc_id,
+					amrnb_in_listener, (void *) audio);
+	if (rc) {
+		MM_ERR("failed to register device event listener\n");
+		goto evt_error;
+	}
+	file->private_data = audio;
+	audio->opened = 1;
+done:
+	mutex_unlock(&audio->lock);
+	return rc;
+evt_error:
+	msm_adsp_put(audio->audrec);
+	audpreproc_aenc_free(audio->enc_id);
+	mutex_unlock(&audio->lock);
+	return rc;
+}
+
+static const struct file_operations audio_in_fops = {
+	.owner		= THIS_MODULE,
+	.open		= audamrnb_in_open,
+	.release	= audamrnb_in_release,
+	.read		= audamrnb_in_read,
+	.write		= audamrnb_in_write,
+	.unlocked_ioctl	= audamrnb_in_ioctl,
+};
+
+struct miscdevice audio_amrnb_in_misc = {
+	.minor	= MISC_DYNAMIC_MINOR,
+	.name	= "msm_amrnb_in",
+	.fops	= &audio_in_fops,
+};
+
+static int __init audamrnb_in_init(void)
+{
+	the_audio_amrnb_in.data = dma_alloc_coherent(NULL, DMASZ,
+				       &the_audio_amrnb_in.phys, GFP_KERNEL);
+	MM_DBG("Memory addr = 0x%8x  Phy addr= 0x%8x ---- \n", \
+		(int) the_audio_amrnb_in.data, (int) the_audio_amrnb_in.phys);
+
+	if (!the_audio_amrnb_in.data) {
+		MM_ERR("Unable to allocate DMA buffer\n");
+		return -ENOMEM;
+	}
+	mutex_init(&the_audio_amrnb_in.lock);
+	mutex_init(&the_audio_amrnb_in.read_lock);
+	spin_lock_init(&the_audio_amrnb_in.dsp_lock);
+	spin_lock_init(&the_audio_amrnb_in.dev_lock);
+	init_waitqueue_head(&the_audio_amrnb_in.wait);
+	init_waitqueue_head(&the_audio_amrnb_in.wait_enable);
+	return misc_register(&audio_amrnb_in_misc);
+}
+
+device_initcall(audamrnb_in_init);
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.c kernel-new/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.c
--- kernel-old/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.c	2011-01-31 14:21:08.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/audio_dev_ctl.c	2011-04-25 00:29:28.000000000 +0400
@@ -106,13 +106,24 @@
 	signed int voice_rx_vol;
 	int tx_mute;
 	int rx_mute;
+	int voice_state;
 };
 
 static struct audio_routing_info routing_info;
 
+int msm_get_voice_state(void)
+{
+        MM_DBG("voice state %d\n", routing_info.voice_state);
+        return routing_info.voice_state;
+}
+EXPORT_SYMBOL(msm_get_voice_state);
+
 int msm_set_voice_mute(int dir, int mute)
 {
 	MM_ERR("dir %x mute %x\n", dir, mute);
+        if (!audio_dev_ctrl.voice_rx_dev
+                || !audio_dev_ctrl.voice_tx_dev)
+                return -EPERM;
 	if (dir == DIR_TX) {
 		routing_info.tx_mute = mute;
 		broadcast_event(AUDDEV_EVT_DEVICE_VOL_MUTE_CHG,
@@ -128,6 +139,9 @@
 
 int msm_set_voice_vol(int dir, s32 volume)
 {
+        if (!audio_dev_ctrl.voice_rx_dev
+                || !audio_dev_ctrl.voice_tx_dev)
+                return -EPERM;
 	if (dir == DIR_TX) {
 		routing_info.voice_tx_vol = volume;
 		broadcast_event(AUDDEV_EVT_DEVICE_VOL_MUTE_CHG,
@@ -570,11 +584,7 @@
 				continue;
 			}
 			set_freq = MAX(*freq, info->set_sample_rate);
-			if (set_freq == info->set_sample_rate) {
-				rc = info->set_sample_rate;
-				*freq = info->set_sample_rate;
-				continue;
-			}
+
 
 			if (clnt_type == AUDDEV_CLNT_DEC) {
 				routing_info.dec_freq[session_id].evt = 1;
@@ -776,10 +786,16 @@
 
 	MM_DBG(": evt_id = %d\n", evt_id);
 
-	if ((evt_id != AUDDEV_EVT_START_VOICE)
-		&& (evt_id != AUDDEV_EVT_END_VOICE)
-		&& (evt_id != AUDDEV_EVT_STREAM_VOL_CHG))
-		dev_info = audio_dev_ctrl_find_dev(dev_id);
+        if ((evt_id != AUDDEV_EVT_START_VOICE)
+                && (evt_id != AUDDEV_EVT_END_VOICE)
+                && (evt_id != AUDDEV_EVT_STREAM_VOL_CHG)
+                && (evt_id != AUDDEV_EVT_VOICE_STATE_CHG)) {
+                dev_info = audio_dev_ctrl_find_dev(dev_id);
+                if (IS_ERR(dev_info)) {
+                        MM_ERR("pass invalid dev_id\n");
+                        return;
+                }
+        }
 
 	if (event.cb != NULL)
 		callback = event.cb;
@@ -787,6 +803,9 @@
 		return;
 	mutex_lock(&session_lock);
 
+        if (evt_id == AUDDEV_EVT_VOICE_STATE_CHG)
+                routing_info.voice_state = dev_id;
+
 	evt_payload = kzalloc(sizeof(union auddev_evt_data),
 			GFP_KERNEL);
 
@@ -811,8 +830,10 @@
 		session_mask = (0x1 << (clnt_id))
 				<< (8 * ((int)callback->clnt_type-1));
 
-		if (evt_id == AUDDEV_EVT_STREAM_VOL_CHG) {
-			MM_DBG("AUDDEV_EVT_STREAM_VOL_CHG\n");
+                if ((evt_id == AUDDEV_EVT_STREAM_VOL_CHG) || 
+                        (evt_id == AUDDEV_EVT_VOICE_STATE_CHG)) {
+			MM_DBG("AUDDEV_EVT_STREAM_VOL_CHG or\
+                                AUDDEV_EVT_VOICE_STATE_CHG\n");
 			goto volume_strm;
 		}
 
@@ -858,14 +879,18 @@
 					evt_payload->freq_info.acdb_dev_id
 						= dev_info->acdb_id;
 				}
-			} else
+			} else if (evt_id == AUDDEV_EVT_VOICE_STATE_CHG)
+                                evt_payload->voice_state =
+                                        routing_info.voice_state;
+                        else
 				evt_payload->routing_id = dev_info->copp_id;
 			callback->auddev_evt_listener(
 					evt_id,
 					evt_payload,
 					callback->private_data);
 sent_dec:
-			if (evt_id != AUDDEV_EVT_STREAM_VOL_CHG)
+                        if ((evt_id != AUDDEV_EVT_STREAM_VOL_CHG) &&
+                                (evt_id != AUDDEV_EVT_VOICE_STATE_CHG))
 				routing_info.dec_freq[clnt_id].freq
 						= dev_info->set_sample_rate;
 
@@ -891,7 +916,10 @@
 					evt_payload->freq_info.acdb_dev_id
 						= dev_info->acdb_id;
 				}
-			} else
+			} else if (evt_id == AUDDEV_EVT_VOICE_STATE_CHG)
+                                evt_payload->voice_state =
+                                        routing_info.voice_state;
+                        else
 				evt_payload->routing_id = dev_info->copp_id;
 			callback->auddev_evt_listener(
 					evt_id,
@@ -907,20 +935,44 @@
 		}
 aud_cal:
 		if (callback->clnt_type == AUDDEV_CLNT_AUDIOCAL) {
+                        int temp_sessions;
 			MM_DBG("AUDDEV_CLNT_AUDIOCAL\n");
-			if (!dev_info->sessions)
+			if (evt_id == AUDDEV_EVT_VOICE_STATE_CHG)
+                                evt_payload->voice_state =
+                                        routing_info.voice_state;
+                        else if (!dev_info->sessions)
 				goto sent_aud_cal;
-			evt_payload->audcal_info.dev_id = dev_info->copp_id;
-			evt_payload->audcal_info.acdb_id =
-				dev_info->acdb_id;
-			evt_payload->audcal_info.dev_type =
-				(dev_info->capability & SNDDEV_CAP_TX) ?
-				SNDDEV_CAP_TX : SNDDEV_CAP_RX;
-			evt_payload->audcal_info.sample_rate =
-				dev_info->set_sample_rate ?
-				dev_info->set_sample_rate :
-				dev_info->sample_rate;
-
+			else {
+                                evt_payload->audcal_info.dev_id =
+                                                dev_info->copp_id;
+                                evt_payload->audcal_info.acdb_id =
+                                                dev_info->acdb_id;
+                                evt_payload->audcal_info.dev_type =
+                                        (dev_info->capability & SNDDEV_CAP_TX) ?
+                                        SNDDEV_CAP_TX : SNDDEV_CAP_RX;
+                                evt_payload->audcal_info.sample_rate =
+                                        dev_info->set_sample_rate ?
+                                        dev_info->set_sample_rate :
+                                        dev_info->sample_rate;
+                        }
+                        if (evt_payload->audcal_info.dev_type ==
+                                                SNDDEV_CAP_TX) {
+                                if (session_id == SESSION_IGNORE)
+                                        temp_sessions = dev_info->sessions;
+                                else
+                                        temp_sessions = session_id;
+                                evt_payload->audcal_info.sessions =
+                                        (temp_sessions >>
+                                                ((AUDDEV_CLNT_ENC-1) * 8));
+                        } else {
+                                if (session_id == SESSION_IGNORE)
+                                        temp_sessions = dev_info->sessions;
+                                else
+                                        temp_sessions = session_id;
+                                evt_payload->audcal_info.sessions =
+                                        (temp_sessions >>
+                                                ((AUDDEV_CLNT_DEC-1) * 8));
+                        }
 			callback->auddev_evt_listener(
 				evt_id,
 				evt_payload,
@@ -966,9 +1018,9 @@
 						voc_vm_info.dev_vm_val.mute =
 							routing_info.rx_mute;
 					else
-						evt_payload->
-						voc_vm_info.dev_vm_val.vol =
-							routing_info.voice_rx_vol;
+	                                        evt_payload->
+	                                        voc_vm_info.dev_vm_val.vol =
+	                                                routing_info.voice_rx_vol;
 				}
 			} else if ((evt_id == AUDDEV_EVT_START_VOICE)
 					|| (evt_id == AUDDEV_EVT_END_VOICE))
@@ -987,7 +1039,10 @@
 						= dev_info->acdb_id;
 				} else
 					goto sent_voc;
-			} else {
+			} else if (evt_id == AUDDEV_EVT_VOICE_STATE_CHG)
+                                evt_payload->voice_state =
+                                                routing_info.voice_state;
+			else {
 				evt_payload->voc_devinfo.dev_type =
 					(dev_info->capability & SNDDEV_CAP_TX) ?
 					SNDDEV_CAP_TX : SNDDEV_CAP_RX;
@@ -1074,6 +1129,7 @@
 	audio_dev_ctrl.num_dev = 0;
 	audio_dev_ctrl.voice_tx_dev = NULL;
 	audio_dev_ctrl.voice_rx_dev = NULL;
+        routing_info.voice_state = VOICE_STATE_INVALID;
 	return misc_register(&audio_dev_ctrl_misc);
 }
 
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c kernel-new/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c
--- kernel-old/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c	2011-01-31 14:21:08.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c	2011-04-25 00:36:10.000000000 +0400
@@ -35,12 +35,16 @@
 #include <mach/qdsp5v2/audpreproc.h>
 #include <mach/qdsp5v2/audio_dev_ctl.h>
 
+
 /* FRAME_NUM must be a power of two */
 #define FRAME_NUM		(8)
 #define FRAME_SIZE		(2052 * 2)
 #define MONO_DATA_SIZE		(2048)
 #define STEREO_DATA_SIZE	(MONO_DATA_SIZE * 2)
 #define DMASZ 			(FRAME_SIZE * FRAME_NUM)
+#define AUDIO_GET_VOICE_STATE   _IOR(AUDIO_IOCTL_MAGIC, 55, unsigned)
+
+extern int msm_get_voice_state(void);
 
 struct buffer {
 	void *data;
@@ -74,6 +78,7 @@
 	uint32_t in_head; /* next buffer dsp will write */
 	uint32_t in_tail; /* next buffer read() will read */
 	uint32_t in_count; /* number of buffers available to read() */
+        uint32_t mode;
 
 	const char *module_name;
 	unsigned queue_ids;
@@ -81,7 +86,9 @@
 
 	uint16_t source; /* Encoding source bit mask */
 	uint32_t device_events; /* device events interested in */
+        uint32_t in_call;
 	uint32_t dev_cnt;
+        int voice_state;
 	spinlock_t dev_lock;
 
 	/* data allocated for various buffers */
@@ -137,7 +144,8 @@
 		MM_DBG("AUDDEV_EVT_DEV_RDY\n");
 		spin_lock_irqsave(&audio->dev_lock, flags);
 		audio->dev_cnt++;
-		audio->source |= (0x1 << evt_payload->routing_id);
+                if (!audio->in_call)
+			audio->source |= (0x1 << evt_payload->routing_id);
 		spin_unlock_irqrestore(&audio->dev_lock, flags);
 
 		if ((audio->running == 1) && (audio->enabled == 1))
@@ -149,7 +157,8 @@
 		MM_DBG("AUDDEV_EVT_DEV_RLS\n");
 		spin_lock_irqsave(&audio->dev_lock, flags);
 		audio->dev_cnt--;
-		audio->source &= ~(0x1 << evt_payload->routing_id);
+                if (!audio->in_call)
+			audio->source &= ~(0x1 << evt_payload->routing_id);
 		spin_unlock_irqrestore(&audio->dev_lock, flags);
 
 		if (!audio->running || !audio->enabled)
@@ -164,6 +173,20 @@
 
 		break;
 	}
+        case AUDDEV_EVT_VOICE_STATE_CHG: {
+                MM_DBG("AUDDEV_EVT_VOICE_STATE_CHG, state = %d\n",
+                                evt_payload->voice_state);
+                audio->voice_state = evt_payload->voice_state;
+                if (audio->in_call && audio->running) {
+                        if (audio->voice_state == VOICE_STATE_INCALL)
+                                audpcm_in_record_config(audio, 1);
+                        else if (audio->voice_state == VOICE_STATE_OFFCALL) {
+                                audpcm_in_record_config(audio, 0);
+                                wake_up(&audio->wait);
+                        }
+                }
+                break;
+        }
 	case AUDDEV_EVT_FREQ_CHG: {
 		MM_DBG("Encoder Driver got sample rate change event\n");
 		MM_DBG("sample rate %d\n", evt_payload->freq_info.sample_rate);
@@ -249,7 +272,9 @@
 	case AUDREC_CMD_MEM_CFG_DONE_MSG: {
 		MM_DBG("CMD_MEM_CFG_DONE MSG DONE\n");
 		audio->running = 1;
-		if (audio->dev_cnt > 0)
+                if ((!audio->in_call && (audio->dev_cnt > 0)) ||
+                        (audio->in_call &&
+                                (audio->voice_state == VOICE_STATE_INCALL)))
 			audpcm_in_record_config(audio, 1);
 		break;
 	}
@@ -366,6 +391,18 @@
 		cmd.destination_activity = AUDIO_RECORDING_TURN_OFF;
 
 	cmd.source_mix_mask = audio->source;
+        if (audio->enc_id == 2) {
+                if ((cmd.source_mix_mask &
+                                INTERNAL_CODEC_TX_SOURCE_MIX_MASK) ||
+                        (cmd.source_mix_mask & AUX_CODEC_TX_SOURCE_MIX_MASK) ||
+                        (cmd.source_mix_mask & VOICE_UL_SOURCE_MIX_MASK) ||
+                        (cmd.source_mix_mask & VOICE_DL_SOURCE_MIX_MASK)) {
+                        cmd.pipe_id = SOURCE_PIPE_1;
+                }
+                if (cmd.source_mix_mask &
+                                AUDPP_A2DP_PIPE_SOURCE_MIX_MASK)
+                        cmd.pipe_id |= SOURCE_PIPE_0;
+        }
 
 	return audpreproc_send_audreccmdqueue(&cmd, sizeof(cmd));
 }
@@ -477,8 +514,12 @@
 		if (copy_to_user((void *) arg, &stats, sizeof(stats)))
 			return -EFAULT;
 		return rc;
-	}
-
+	} else if (cmd == AUDIO_GET_VOICE_STATE) {
+                int vstate = audio->voice_state;
+                if (copy_to_user((void *) arg, &vstate, sizeof(vstate)))
+                        return -EFAULT;
+                return rc;
+        }
 	mutex_lock(&audio->lock);
 	switch (cmd) {
 	case AUDIO_START: {
@@ -486,6 +527,10 @@
 		/* Poll at 48KHz always */
 		freq = 48000;
 		MM_DBG("AUDIO_START\n");
+                if (audio->in_call && (audio->voice_state != VOICE_STATE_INCALL)) {
+                        rc = -EPERM;
+                        break;
+                }
 		rc = msm_snddev_request_freq(&freq, audio->enc_id,
 					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 		MM_DBG("sample rate configured %d sample rate requested %d\n",
@@ -510,6 +555,7 @@
 			else
 				rc = 0;
 		}
+		audio->stopped = 0;
 		break;
 	}
 	case AUDIO_STOP: {
@@ -543,17 +589,16 @@
 		}
 		if (cfg.channel_count == 1) {
 			cfg.channel_count = AUDREC_CMD_MODE_MONO;
+                        audio->buffer_size = MONO_DATA_SIZE;
 		} else if (cfg.channel_count == 2) {
 			cfg.channel_count = AUDREC_CMD_MODE_STEREO;
+                        audio->buffer_size = STEREO_DATA_SIZE;
 		} else {
 			rc = -EINVAL;
 			break;
 		}
 		audio->samp_rate = cfg.sample_rate;
 		audio->channel_mode = cfg.channel_count;
-		audio->buffer_size =
-				audio->channel_mode ? STEREO_DATA_SIZE : \
-					MONO_DATA_SIZE;
 		break;
 	}
 	case AUDIO_GET_CONFIG: {
@@ -570,6 +615,34 @@
 			rc = -EFAULT;
 		break;
 	}
+        case AUDIO_SET_INCALL: {
+                struct msm_voicerec_mode cfg;
+                unsigned long flags;
+                MM_DBG("AUDIO_SET_INCALL\n");
+                if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
+                        rc = -EFAULT;
+                        break;
+                }
+                if (cfg.rec_mode != VOC_REC_BOTH &&
+                        cfg.rec_mode != VOC_REC_UPLINK &&
+                        cfg.rec_mode != VOC_REC_DOWNLINK) {
+                        MM_ERR("invalid rec_mode\n");
+                        rc = -EINVAL;
+                        break;
+                } else {
+                        spin_lock_irqsave(&audio->dev_lock, flags);
+                        if (cfg.rec_mode == VOC_REC_UPLINK)
+                                audio->source = VOICE_UL_SOURCE_MIX_MASK;
+                        else if (cfg.rec_mode == VOC_REC_DOWNLINK)
+                                audio->source = VOICE_DL_SOURCE_MIX_MASK;
+                        else
+                                audio->source = VOICE_DL_SOURCE_MIX_MASK |
+                                                VOICE_UL_SOURCE_MIX_MASK ;
+                        audio->in_call = 1;
+                        spin_unlock_irqrestore(&audio->dev_lock, flags);
+                }
+                break;
+        }
 	case AUDIO_GET_SESSION_ID: {
 		if (copy_to_user((void *) arg, &audio->enc_id,
 			sizeof(unsigned short))) {
@@ -598,18 +671,27 @@
 
 	mutex_lock(&audio->read_lock);
 	while (count > 0) {
-		rc = wait_event_interruptible(
-			audio->wait, (audio->in_count > 0) || audio->stopped ||
-			audio->abort);
+                rc = wait_event_interruptible(
+                        audio->wait, (audio->in_count > 0) || audio->stopped ||
+                        audio->abort || (audio->in_call && audio->running &&
+                                (audio->voice_state == VOICE_STATE_OFFCALL)));
 
 		if (rc < 0)
 			break;
 
-		if (audio->stopped && !audio->in_count) {
-			MM_DBG("Driver in stop state, No more buffer to read");
-			rc = 0;/* End of File */
-			break;
-		}
+                if (!audio->in_count) {
+                        if (audio->stopped) {
+                                MM_DBG("Driver in stop state, No more \
+                                                buffer to read");
+                                rc = 0;/* End of File */
+                                break;
+                        } else if (audio->in_call && audio->running &&
+                                (audio->voice_state == VOICE_STATE_OFFCALL)) {
+                                MM_DBG("Not Permitted Voice Terminated\n");
+                                rc = -EPERM; /* Voice Call stopped */
+                                break;
+                        }
+                }
 
 		if (audio->abort) {
 			rc = -EPERM; /* Not permitted due to abort */
@@ -662,6 +744,7 @@
 	struct audio_in *audio = file->private_data;
 
 	mutex_lock(&audio->lock);
+        audio->in_call = 0;
 	/* with draw frequency for session
 	   incase not stopped the driver */
 	msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX,
@@ -694,8 +777,8 @@
 	audio->channel_mode = AUDREC_CMD_MODE_MONO;
 	audio->buffer_size = MONO_DATA_SIZE;
 	audio->samp_rate = 8000;
-	audio->enc_type = ENC_TYPE_WAV;
-	audio->source = INTERNAL_CODEC_TX_SOURCE_MIX_MASK;
+	audio->enc_type = ENC_TYPE_WAV | audio->mode;
+        audio->mode = MSM_AUD_ENC_MODE_TUNNEL;
 
 	encid = audpreproc_aenc_alloc(audio->enc_type, &audio->module_name,
 			&audio->queue_ids);
@@ -719,7 +802,10 @@
 	audio->abort = 0;
 	audpcm_in_flush(audio);
 	audio->device_events = AUDDEV_EVT_DEV_RDY | AUDDEV_EVT_DEV_RLS |
-				AUDDEV_EVT_FREQ_CHG;
+				AUDDEV_EVT_FREQ_CHG |
+                                AUDDEV_EVT_VOICE_STATE_CHG;
+
+        audio->voice_state = msm_get_voice_state();
 
 	rc = auddev_register_evt_listner(audio->device_events,
 					AUDDEV_CLNT_ENC, audio->enc_id,
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/Makefile kernel-new/arch/arm/mach-msm/qdsp5v2/Makefile
--- kernel-old/arch/arm/mach-msm/qdsp5v2/Makefile	2011-01-31 14:21:09.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/Makefile	2011-04-25 00:29:28.000000000 +0400
@@ -1,10 +1,7 @@
 obj-y += afe.o audio_interct.o mi2s.o audio_dev_ctl.o voice.o snddev_data.o
 obj-$(CONFIG_MARIMBA_CODEC) += snddev_icodec.o lpa.o
-#obj-y += audio_pcm.o audio_wma.o audio_aac.o audio_amrnb.o
-#obj-y += audio_amrwb.o audio_wmapro.o audio_adpcm.o audio_evrc.o audio_qcelp.o
 obj-y += aux_pcm.o snddev_ecodec.o audio_out.o audpp.o
 obj-y += audio_mp3.o audio_lpa.o mp3_funcs.o pcm_funcs.o
-obj-y += audpreproc.o audio_pcm_in.o
-#obj-y += audio_evrc_in.o audio_qcelp_in.o audio_aac_in.o audio_amrnb_in.o
+obj-y += audpreproc.o audio_pcm_in.o audio_amrnb_in.o
 obj-y += adsp.o adsp_driver.o adsp_info.o
-obj-y += audio_acdb.o
+obj-y += audio_acdb.o 
diff -Naur kernel-old/arch/arm/mach-msm/qdsp5v2/voice.c kernel-new/arch/arm/mach-msm/qdsp5v2/voice.c
--- kernel-old/arch/arm/mach-msm/qdsp5v2/voice.c	2011-01-31 14:21:08.000000000 +0300
+++ kernel-new/arch/arm/mach-msm/qdsp5v2/voice.c	2011-04-25 00:29:28.000000000 +0400
@@ -723,6 +723,8 @@
 						rc = voice_cmd_device_info(v);
 						rc = voice_cmd_acquire_done(v);
 						v->voc_state = VOICE_ACQUIRE;
+                                                broadcast_event(AUDDEV_EVT_VOICE_STATE_CHG,
+                                                        VOICE_STATE_INCALL, SESSION_IGNORE);
 						pr_info("voc_state -> VOICE_ACQUIRE\n");
 					} else {
 						pr_info("start waiting for "
@@ -731,18 +733,21 @@
 							v->dev_wait,
 							(v->dev_state == DEV_READY)
 							|| (atomic_read(&v->rel_start_flag) == 1));
-						if (atomic_read(&v->rel_start_flag)
-							== 1) {
+						if (atomic_read(&v->rel_start_flag) == 1) {
 							v->voc_state = VOICE_RELEASE;
 							pr_info("voc_state -> VOICE_RELEASE\n");
 							atomic_dec(&v->rel_start_flag);
 							msm_snddev_withdraw_freq(0,
 								SNDDEV_CAP_TX, AUDDEV_CLNT_VOC);
+                                                        broadcast_event(AUDDEV_EVT_VOICE_STATE_CHG,
+                                                                VOICE_STATE_OFFCALL, SESSION_IGNORE);
 						} else {
 							voice_change_sample_rate(v);
 							rc = voice_cmd_device_info(v);
 							rc = voice_cmd_acquire_done(v);
 							v->voc_state = VOICE_ACQUIRE;
+                                                        broadcast_event(AUDDEV_EVT_VOICE_STATE_CHG,
+                                                                VOICE_STATE_INCALL, SESSION_IGNORE);
 							pr_info("voc_state -> VOICE_ACQUIRE\n");
 						}
 					}
@@ -764,8 +769,9 @@
 					(v->dev_state == DEV_INIT)) {
 					v->voc_state = VOICE_RELEASE;
 					pr_info("voc_state -> VOICE_RELEASE\n");
-					msm_snddev_withdraw_freq(0, SNDDEV_CAP_TX,
-						AUDDEV_CLNT_VOC);
+					msm_snddev_withdraw_freq(0, SNDDEV_CAP_TX, AUDDEV_CLNT_VOC);
+                                        broadcast_event(AUDDEV_EVT_VOICE_STATE_CHG,
+                                                VOICE_STATE_OFFCALL,SESSION_IGNORE);
 				} else {
 					/* wait for the dev_state = RELEASE */
 					pr_info("start waiting for "
@@ -779,8 +785,9 @@
 						rc = voice_cmd_release_done(v);
 					v->voc_state = VOICE_RELEASE;
 					pr_info("voc_state -> VOICE_RELEASE\n");
-					msm_snddev_withdraw_freq(0, SNDDEV_CAP_TX,
-						AUDDEV_CLNT_VOC);
+					msm_snddev_withdraw_freq(0, SNDDEV_CAP_TX, AUDDEV_CLNT_VOC);
+                                        broadcast_event(AUDDEV_EVT_VOICE_STATE_CHG,
+                                                VOICE_STATE_OFFCALL,SESSION_IGNORE);
 				}
 				if (atomic_read(&v->rel_start_flag))
 					atomic_dec(&v->rel_start_flag);
@@ -825,6 +832,8 @@
 				/* update voice state */
 				v->voc_state = VOICE_ACQUIRE;
 				pr_info("voc_state -> VOICE_ACQUIRE\n");
+                                broadcast_event(AUDDEV_EVT_VOICE_STATE_CHG,
+                                        VOICE_STATE_INCALL, SESSION_IGNORE);
 			} else {
 				MM_ERR("Get DEV_CHANGE_READY "
 					"at the wrong voc_state %d\n", v->voc_state);
